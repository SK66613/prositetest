<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' https: data: blob: 'unsafe-inline';
                 connect-src 'self' https://*.workers.dev https://tg-calendar.cyberian13.workers.dev data:;
                 img-src 'self' https: data: blob:;
                 font-src 'self' https: data:;">
  <title>Онлайн‑запись</title>
  <style>
    :root{ --bg:#0b0c15; --text:#f3f6fa; --muted:#a7acc2; --primary:#7b5bff; --mint:#3de0c5; --stroke:rgba(255,255,255,.1); }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .container{ max-width:920px; margin:0 auto; padding:16px; }
    h1{ margin:8px 0 16px; font-size:22px }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .card{ background:rgba(255,255,255,.05); border:1px solid var(--stroke); border-radius:16px; padding:14px; margin:10px 0 }
    .muted{ color:var(--muted) }

    /* calendar */
    .cal{ user-select:none }
    .cal-head{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px }
    .cal-head .mon{ font-weight:800 }
    .cal-head button{ border:1px solid var(--stroke); background:transparent; color:var(--text); border-radius:10px; padding:6px 10px; cursor:pointer }
    .cal-grid{ display:grid; grid-template-columns:repeat(7,1fr); gap:6px }
    .cal-dow{ text-align:center; font-weight:700; opacity:.7 }
    .day{ height:36px; display:grid; place-items:center; border:1px solid var(--stroke); border-radius:10px; background:rgba(255,255,255,.03); cursor:pointer; font-weight:600 }
    .day.off{ opacity:.35; pointer-events:none }
    .day.sel{ color:#fff; background:linear-gradient(135deg,var(--primary),var(--mint)); border-color:transparent }

    /* slots */
    #slots{ display:none; gap:8px; flex-wrap:wrap }
    #slots.show{ display:flex }
    #slots .btn{ border:1px solid var(--stroke); background:transparent; color:var(--text); border-radius:12px; padding:8px 10px; cursor:pointer }
    #slots .btn.active{ background:linear-gradient(135deg,var(--primary),var(--mint)); color:#fff; border-color:transparent }
    #slots .btn.off{ opacity:.45; pointer-events:none }

    /* controls */
    .pill{ border:1px solid var(--stroke); border-radius:999px; padding:6px 10px; cursor:pointer; background:transparent; color:var(--text) }
    .pill.active{ background:linear-gradient(135deg,var(--primary),var(--mint)); color:#fff; border-color:transparent }
    input, select{ background:#0f1221; color:var(--text); border:1px solid var(--stroke); border-radius:10px; padding:8px 10px; outline:none }
    .actions{ display:flex; gap:10px; flex-wrap:wrap }
    .btnp{ background:linear-gradient(135deg,var(--primary),var(--mint)); color:#fff; border:0; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer }
    .btng{ background:transparent; color:var(--text); border:1px solid var(--stroke); border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer }
    .note{ font-size:13px; color:var(--muted) }
  </style>
</head>
<body>
  <div class="container">
    <h1>Онлайн‑запись</h1>

    <div class="card">
      <div id="cal" class="cal">
        <div class="cal-head">
          <button id="prevM" aria-label="Prev month">←</button>
          <div class="mon" id="monLabel"></div>
          <button id="nextM" aria-label="Next month">→</button>
        </div>
        <div class="cal-grid" id="grid">
          <div class="cal-dow">Пн</div><div class="cal-dow">Вт</div><div class="cal-dow">Ср</div><div class="cal-dow">Чт</div><div class="cal-dow">Пт</div><div class="cal-dow">Сб</div><div class="cal-dow">Вс</div>
        </div>
      </div>
      <div style="margin-top:8px" class="row">
        <span class="muted">Длительность:</span>
        <button class="pill dur" data-min="30">30 мин</button>
        <button class="pill dur" data-min="60">60 мин</button>
        <button class="pill dur" data-min="90">90 мин</button>
      </div>
      <div id="slots" class="row" style="margin-top:8px;"></div>
      <div id="noSlots" class="note" style="display:none;margin-top:8px;">Нет свободных слотов</div>
    </div>

    <div class="card">
      <div class="row">
        <label class="muted">Формат:</label>
        <select id="format">
          <option value="call">Звонок</option>
          <option value="zoom">Zoom</option>
          <option value="tg">Телеграм</option>
        </select>
        <label class="muted">Контакт:</label>
        <input id="contact" placeholder="@username или +7..." style="min-width:220px" />
      </div>
      <div class="actions" style="margin-top:10px">
        <button id="btnHold" class="btng">Удержать слот (5 мин)</button>
        <button id="btnBook" class="btnp">Записаться</button>
      </div>
      <div id="status" class="note" style="margin-top:6px"></div>
    </div>
  </div>

<script>
const APP_CONFIG = {
  WORKER_BASE: "https://tg-calendar.cyberian13.workers.dev/",
  API_KEY: "dev-123",     // поменяй при необходимости
  TZ: (Intl.DateTimeFormat().resolvedOptions().timeZone || "Europe/Moscow")
};

// ---- helpers ----
const dd2 = n => String(n).padStart(2, "0");
const fmtISO = d => d.getFullYear()+"-"+dd2(d.getMonth()+1)+"-"+dd2(d.getDate());
function el(q,root=document){ return root.querySelector(q); }
function els(q,root=document){ return Array.from(root.querySelectorAll(q)); }
function setText(id, v){ const n = document.getElementById(id); if(n) n.textContent = v; }
function haptic(style){ try{ Telegram && Telegram.WebApp && Telegram.WebApp.HapticFeedback.impactOccurred(style||"light"); }catch(_){/*no-op*/} }

// API (Cloudflare Worker)
async function apiGET(params){
  const u = new URL(APP_CONFIG.WORKER_BASE);
  Object.entries(params).forEach(([k,v])=> u.searchParams.set(k, String(v)));
  // API key fallback если нет tg_init
  try{
    const tgInit = Telegram?.WebApp?.initData || "";
    if (tgInit) u.searchParams.set("tg_init", tgInit);
    else if (APP_CONFIG.API_KEY) u.searchParams.set("key", APP_CONFIG.API_KEY);
  }catch(_){ if (APP_CONFIG.API_KEY) u.searchParams.set("key", APP_CONFIG.API_KEY); }
  const r = await fetch(u.toString(), { credentials:"omit" });
  const j = await r.json();
  return j;
}
const API = {
  async freeSlots(fromISO, toISO){
    return apiGET({ mode:"free_slots", from:fromISO, to:toISO, tz:APP_CONFIG.TZ, gran:30 });
  },
  async holdSlot(dateISO, timeHHMM, durationMin){
    return apiGET({ mode:"event", type:"hold_slot", date:dateISO, time:timeHHMM, duration_min:durationMin, tz:APP_CONFIG.TZ });
  },
  async book(dateISO, timeHHMM, durationMin, format, contact){
    return apiGET({ mode:"event", type:"consult_booking", date:dateISO, time:timeHHMM, duration_min:durationMin, format, contact, tz:APP_CONFIG.TZ });
  }
};

// ---- state ----
const state = {
  view: new Date(),           // текущий показываемый месяц
  monthCache: new Map(),      // "YYYY-MM" -> {days, gran, tz}
  gran: 30,
  selDate: null,              // 'YYYY-MM-DD'
  selTime: null,              // 'HH:MM'
  duration: 30,               // minutes
};

// UI: set default duration 30 active
function initDuration(){
  els(".dur").forEach(b=>{
    b.classList.toggle("active", Number(b.dataset.min)===state.duration);
    b.addEventListener("click", ()=>{
      const keep = state.selTime;
      state.duration = Number(b.dataset.min)||30;
      els(".dur").forEach(x=>x.classList.remove("active"));
      b.classList.add("active");
      if (state.selDate){ renderSlots(state.selDate, keep); }
    });
  });
}

// Calendar render (no tails)
function renderCalendar(){
  const y = state.view.getFullYear();
  const m = state.view.getMonth(); // 0..11
  const monthLabel = state.view.toLocaleDateString("ru-RU", { month:"long", year:"numeric" }).replace(/^./, c=>c.toUpperCase());
  setText("monLabel", monthLabel);

  const grid = el("#grid");
  // clear previous days (keep dow labels first 7 nodes)
  grid.querySelectorAll(".day").forEach(n=>n.remove());

  const firstDay = new Date(y, m, 1);
  const lastDay = new Date(y, m+1, 0);
  const startDow = (firstDay.getDay()+6)%7; // Monday=0

  // prepend blanks for offset
  for (let i=0;i<startDow;i++){
    const span = document.createElement("div");
    grid.appendChild(span);
  }

  const todayISO = fmtISO(new Date());
  for (let d=1; d<=lastDay.getDate(); d++){
    const iso = y+"-"+dd2(m+1)+"-"+dd2(d);
    const btn = document.createElement("button");
    btn.className = "day";
    btn.textContent = String(d);
    btn.dataset.iso = iso;
    if (iso < todayISO) btn.classList.add("off"); // прошлые дни не кликаются

    btn.addEventListener("click", ()=>{
      els(".day").forEach(x=>x.classList.remove("sel"));
      btn.classList.add("sel");
      state.selDate = iso;
      renderSlots(iso, state.selTime); // try keep previous time
      haptic("light");
    });

    grid.appendChild(btn);
  }

  // fetch free slots for month (from cache if available)
  loadMonthFreeSlots(y, m+1).then(()=>applyDayAvailability());
}

// Load/Cache month data
async function loadMonthFreeSlots(year, month1){
  const key = year+"-"+dd2(month1);
  if (state.monthCache.has(key)) return;
  const fromISO = year+"-"+dd2(month1)+"-01";
  const last = new Date(year, month1, 0).getDate();
  const toISO = year+"-"+dd2(month1)+"-"+dd2(last);
  const res = await API.freeSlots(fromISO, toISO);
  if (res && res.ok){
    state.monthCache.set(key, res);
    state.gran = res.gran || 30;
  } else {
    console.warn("freeSlots error", res);
  }
}
function getMonthData(dateISO){
  const [yy,mm] = dateISO.split("-");
  return state.monthCache.get(yy+"-"+mm) || { days:{} };
}
function applyDayAvailability(){
  // mark days with no slots as off (based on server data)
  els(".day").forEach(btn=>{
    const iso = btn.dataset.iso;
    if (!iso) return;
    const md = getMonthData(iso);
    if (!Object.prototype.hasOwnProperty.call(md.days || {}, iso)){
      // no info -> leave as is (allows server-driven unavailability later)
      return;
    }
    const arr = md.days[iso] || [];
    const ok = Array.isArray(arr) && arr.length>0;
    btn.classList.toggle("off", !ok || (iso < fmtISO(new Date())));
  });
}

// Slot filtering for duration: need continuous steps of gran
function filterStarts(starts, needMin, step){
  if (!Array.isArray(starts)) return [];
  const stepMin = step || state.gran || 30;
  if (needMin <= stepMin) return starts.slice();
  const needSteps = Math.ceil(needMin/stepMin);
  const toMin = t => { const m=t.match(/(\d{1,2}):(\d{2})/); return m? (+m[1])*60+(+m[2]) : null; };
  const set = new Set(starts.map(toMin).filter(v=>v!=null));
  return starts.filter(t=>{
    const m = toMin(t); if (m==null) return false;
    for (let i=0;i<needSteps;i++){ if (!set.has(m + i*stepMin)) return false; }
    return true;
  });
}

// Render slots for selected date
function renderSlots(dateISO, tryKeep){
  const box = el("#slots");
  const empty = el("#noSlots");
  box.innerHTML = "";
  empty.style.display = "none";
  box.classList.add("show");

  const md = getMonthData(dateISO);
  const all = (md.days && md.days[dateISO]) ? md.days[dateISO] : [];
  const filtered = filterStarts(all, state.duration, md.gran||state.gran);

  if (!filtered.length){
    empty.style.display = "block";
    state.selTime = null;
    return;
  }

  let keepTime = (tryKeep && filtered.includes(tryKeep)) ? tryKeep : null;
  filtered.forEach(t=>{
    const b = document.createElement("button");
    b.className = "btn";
    b.textContent = t;
    b.dataset.time = t;
    b.addEventListener("click", ()=>{
      els("#slots .btn").forEach(x=>x.classList.remove("active"));
      b.classList.add("active");
      state.selTime = t;
      haptic("light");
    });
    if (!keepTime && !state.selTime){ keepTime = t; }
    box.appendChild(b);
  });

  // apply active selection
  const toSelect = keepTime || state.selTime;
  if (toSelect){
    const found = els("#slots .btn").find(x => (x.dataset.time||x.textContent)===toSelect);
    if (found){ found.classList.add("active"); state.selTime = toSelect; }
  }
}

// Booking actions
async function holdSelected(){
  if (!state.selDate || !state.selTime){ setStatus("Выберите дату и время"); return; }
  const r = await API.holdSlot(state.selDate, state.selTime, state.duration);
  if (r && r.ok){
    setStatus("Слот удержан до: " + (r.hold_until || ""));
  } else {
    setStatus("Не удалось удержать слот" + (r && r.error ? " ("+r.error+")" : ""));
    // refresh month to get actual availability
    const d = new Date(state.selDate); await loadMonthFreeSlots(d.getFullYear(), d.getMonth()+1); applyDayAvailability(); renderSlots(state.selDate);
  }
}
async function bookSelected(){
  if (!state.selDate || !state.selTime){ setStatus("Выберите дату и время"); return; }
  const format = el("#format").value;
  const contact = el("#contact").value.trim();
  const r = await API.book(state.selDate, state.selTime, state.duration, format, contact);
  if (r && r.ok){
    setStatus("Готово! Бронирование №"+(r.booking_id||''));
    // remove slot locally (без перезагрузки)
    const md = getMonthData(state.selDate);
    if (md && md.days && Array.isArray(md.days[state.selDate])){
      md.days[state.selDate] = md.days[state.selDate].filter(t => t !== state.selTime);
      renderSlots(state.selDate);
      applyDayAvailability();
    }
  } else {
    setStatus("Не удалось записаться" + (r && r.error ? " ("+r.error+")" : ""));
    // sync month in case slot became unavailable
    const d = new Date(state.selDate); await loadMonthFreeSlots(d.getFullYear(), d.getMonth()+1); applyDayAvailability(); renderSlots(state.selDate);
  }
}
function setStatus(msg){ el("#status").textContent = msg || ""; }

// nav
el("#prevM").addEventListener("click", ()=>{ state.view.setMonth(state.view.getMonth()-1); renderCalendar(); });
el("#nextM").addEventListener("click", ()=>{ state.view.setMonth(state.view.getMonth()+1); renderCalendar(); });

// init
initDuration();
renderCalendar();
el("#btnHold").addEventListener("click", holdSelected);
el("#btnBook").addEventListener("click", bookSelected);
</script>
</body>
</html>
